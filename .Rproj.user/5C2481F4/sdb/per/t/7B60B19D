{
    "contents" : "# This function returns the mean and upper and lower bounds of the total electricity output \n# for a desired postcode on our selected Month/Day combination. This function relies on the function\n# hourly_rad and uses the temperature output of the temperature_interpolation function as an input\n#\n# Input: Postcode, Desired MonthDay combination, desired data folder, installed PV capacity per postcode\n# & temperature output from the temp_vector function\n#\n# Output: Means and Upper and lower bounds of the 90th percentile for the hourly PV output for our desired\n# Month/Day combination\n#\n#\n#\n\n\npostcode_pv_output <- function(Postcode, MonthDay,data.folder,InstalledPV,temp_vector){\n\n\n# Create a vector of the  folders for each year\na<-list.dirs(path = data.folder)\n\n# For each year load the respective postcode data frame and extract the row which contains the Month-Day-Hour combination\n# append to data frame df1\nfor(i in 2:length(a)){\n  tvalue <- loadToEnv(paste0(a[i],\"/P\",Postcode,\".Rdata\"))[[paste0(\"POA.\",Postcode)]]; \n  c<-tvalue[which(grepl(MonthDay,as.character(tvalue$Date))==1),]\n  if (exists('df1')) df1 <- rbind(df1,c)\n  else df1<-c\n}\n\n# Creates vector representing hours of day\ntime_vector<-as.character(seq(0,23))\n\n# Extracts Irradiation values for each hour\nsolar_hourly_vector<-lapply(time_vector, function(x) hourly_rad(x,df1))\nsolar_hourly_vector<-as.data.frame(solar_hourly_vector)\n\nnames(solar_hourly_vector)<-time_vector\n\n# Extracts means and standard deviations for each hour\nmeans <- colMeans(solar_hourly_vector,na.rm=TRUE)\nstandard_deviations <- sapply(solar_hourly_vector, sd)\n\n# Multiplier for double sided 90% confidence level\nmultiplier <- 1.64\n\n# Creates upper and lower bounds functions\nlower_bounds <- means-multiplier*standard_deviations\nupper_bounds <-  means+multiplier*standard_deviations\n\n# Creates data frames for the fProd function using the irradiation and temperature\ninclin <- data.frame(Gef=means,Ta=temp_vector)\ninclin_min <- data.frame(Gef=lower_bounds,Ta=temp_vector)\ninclin_max <- data.frame(Gef=upper_bounds,Ta=temp_vector)\n\n# Applies fProd to each vector\npv_productivity <- fProd(inclin)\npv_productivity_min <- fProd(inclin_min)\npv_productivity_max <- fProd(inclin_max)\n\n# Divides the simulated AC output by the default installed capacity (25,000W) to obtain the efficiency\npv_productivity <- pv_productivity$Pac/25000\npv_productivity_min <- pv_productivity_min$Pac/25000\npv_productivity_max <- pv_productivity_max$Pac/25000\n\n\n# Extracts PV capacity for out desired postcode\ndf3<-InstalledPV[which(grepl(Postcode,as.character(InstalledPV$Small.Unit.Installation.Postcode))==1),]\n\ninstalledcap <- df3[,2]\n\n# Calculates Estimate of total PV production for the postcode\ntotal_prod <- rbind(pv_productivity_min,pv_productivity,pv_productivity_max)\ntotal_prod[is.na(total_prod)]<-0\ntotal_prod <- total_prod#*installedcap\n\nreturn(total_prod)\n\n}",
    "created" : 1432210079021.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3431171363",
    "id" : "7B60B19D",
    "lastKnownWriteTime" : 1431573735,
    "path" : "C:/SolarPVUWA/R/postcode_pv_output.R",
    "project_path" : "R/postcode_pv_output.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}